# app/__init__.py
from __future__ import annotations

import os
from datetime import timedelta

from flask import Flask, jsonify, send_from_directory
from dotenv import load_dotenv

# Your shared extensions (already in your repo)
# If your project names differ, adjust these imports.
from .extensions import db, ma, migrate, cache, limiter, cors

# Blueprints
from .routes.customers import bp as customers_bp
from .routes.mechanics import bp as mechanics_bp
from .routes.inventory import bp as inventory_bp
from .routes.service_tickets import bp as service_tickets_bp
from .routes.auth import bp as auth_bp

# Optional: Swagger UI (pip install in venv: flask-swagger-ui==4.11.1)
try:
    from flask_swagger_ui import get_swaggerui_blueprint
except Exception:  # keep app booting even if package not installed
    get_swaggerui_blueprint = None


def _configure_app(app: Flask) -> None:
    """
    Centralized config loading:
      1) .env (dotenv)
      2) instance/config.py (optional)
      3) config.py (optional defaults)
      4) environment variables override
    """

    # 1) .env
    load_dotenv(override=False)

    # sensible defaults for local dev
    app.config.setdefault("SECRET_KEY", os.getenv("SECRET_KEY", "dev-secret-change-me"))
    app.config.setdefault("JWT_SECRET_KEY", os.getenv("JWT_SECRET_KEY", "dev-jwt-secret-change-me"))

    # DB: prefer explicit env; fall back to local SQLite for dev
    app.config.setdefault(
        "SQLALCHEMY_DATABASE_URI",
        os.getenv("SQLALCHEMY_DATABASE_URI", "sqlite:///mech_shop.db"),
    )
    app.config.setdefault("SQLALCHEMY_TRACK_MODIFICATIONS", False)

    # Cache (SimpleCache for dev)
    app.config.setdefault("CACHE_TYPE", os.getenv("CACHE_TYPE", "SimpleCache"))
    app.config.setdefault("CACHE_DEFAULT_TIMEOUT", int(os.getenv("CACHE_DEFAULT_TIMEOUT", "120")))

    # CORS: default allow all in dev; lock down for prod
    app.config.setdefault("CORS_ORIGINS", os.getenv("CORS_ORIGINS", "*"))

    # Limiter
    # In-memory store by default (dev); use env to point to Redis in prod
    app.config.setdefault("RATELIMIT_DEFAULT", os.getenv("RATELIMIT_DEFAULT", "30/minute"))
    app.config.setdefault("RATELIMIT_ENABLED", os.getenv("RATELIMIT_ENABLED", "True").lower() == "true")
    app.config.setdefault("RATELIMIT_STORAGE_URI", os.getenv("RATELIMIT_STORAGE_URI", ""))  # e.g. redis://127.0.0.1:6379/3

    # Flask basics
    app.config.setdefault("JSON_SORT_KEYS", False)
    app.config.setdefault("PERMANENT_SESSION_LIFETIME", timedelta(days=7))

    # 2) instance/config.py (optional, not required)
    # This allows machine-local overrides without committing secrets
    app.config.from_pyfile("config.py", silent=True)

    # 3) project-level defaults (optional)
    try:
        from ..config import Config  # type: ignore
        app.config.from_object(Config)
    except Exception:
        pass

    # 4) explicit env overrides already respected via os.getenv above


def _init_extensions(app: Flask) -> None:
    # DB / Marshmallow / Migrations
    db.init_app(app)
    ma.init_app(app)
    migrate.init_app(app, db)

    # Cache
    cache.init_app(app)

    # CORS
    cors.init_app(app, resources={r"/*": {"origins": app.config.get("CORS_ORIGINS", "*")}})

    # Limiter
    if app.config.get("RATELIMIT_ENABLED", True):
        storage_uri = app.config.get("RATELIMIT_STORAGE_URI") or None
        # If you set RATELIMIT_STORAGE_URI=redis://..., extensions.limiter should be created with that
        limiter.init_app(app, storage_uri=storage_uri)
    else:
        # Still init so decorators work; disable globally
        limiter.enabled = False
        limiter.init_app(app)


def _register_blueprints(app: Flask) -> None:
    app.register_blueprint(auth_bp, url_prefix="/auth")
    app.register_blueprint(customers_bp, url_prefix="/customers")
    app.register_blueprint(mechanics_bp, url_prefix="/mechanics")
    app.register_blueprint(inventory_bp, url_prefix="/inventory")
    # NOTE: your project uses hyphen path for tickets
    app.register_blueprint(service_tickets_bp, url_prefix="/service-tickets")


def _register_health_routes(app: Flask) -> None:
    @app.get("/")
    def index():
        return jsonify(
            {
                "ok": True,
                "service": "mechanic_shop_api_advanced",
                "try": ["/health", "/customers/", "/mechanics/", "/mechanics/top", "/inventory/", "/service-tickets/"],
            }
        )

    @app.get("/health")
    @cache.cached(timeout=30)
    def health():
        return jsonify({"ok": True, "message": "running", "service": "mechanic_shop_api_advanced"}), 200


def _register_swagger(app: Flask) -> None:
    """
    Mounts Swagger UI at /docs and serves openapi.yaml from project root.
    Safe if flask-swagger-ui is not installed (no crash).
    """
    if get_swaggerui_blueprint is None:
        app.logger.warning("Swagger UI not enabled: flask-swagger-ui not installed")
        return

    # Serve the YAML file directly from the project root
    def _serve_openapi_yaml():
        return send_from_directory(".", "openapi.yaml", mimetype="text/yaml")

    app.add_url_rule("/openapi.yaml", "openapi_yaml", _serve_openapi_yaml)

    swagger_url = "/docs"
    api_url = "/openapi.yaml"
    swagger_bp = get_swaggerui_blueprint(
        swagger_url, api_url, config={"app_name": "Mechanic Shop API Advanced"}
    )
    app.register_blueprint(swagger_bp, url_prefix=swagger_url)


def create_app() -> Flask:
    # instance_relative_config enables instance/config.py
    app = Flask(__name__, instance_relative_config=True)

    _configure_app(app)
    _init_extensions(app)
    _register_blueprints(app)
    _register_health_routes(app)
    _register_swagger(app)

    # Friendly 429 response
    @app.errorhandler(429)
    def ratelimit_handler(e):
        return jsonify({"error": "rate limit exceeded", "detail": str(e.description)}), 429

    return app

